# RFC 021: Gross-to-Net Return Decomposition (Final)

**Status:** Final (For Approval)
**Owner:** Senior Architect
**Reviewers:** Perf Engine, Risk, PMs, Compliance
**Related:** All core analytics endpoints, RFC-025 (Reproducibility)

## 1\. Executive Summary

This document specifies the final design for a new, comprehensive **Gross-to-Net Return Decomposition Framework**. A critical requirement for investment reporting is to provide transparent accounting for all factors that cause the net return experienced by an investor to differ from the gross return generated by the investment strategy. This framework addresses this need directly.

This enhancement introduces a unified model for processing **Management Fees, Performance Fees, Transaction Costs, and Taxes**. The engine will produce a clear **Gross-to-Net "bridge"**, showing the specific impact of each cost component in basis points. This decomposition will be consistently applied across all relevant analytics, including TWR, MWR, Contribution, and Attribution.

The API is designed for maximum flexibility, supporting both **supplied** costs (e.g., from a transaction ledger) and **computed** costs (e.g., accruing a management fee or calculating a complex performance fee with high-water marks). This is a foundational feature for any reporting that requires auditability and transparency, building client trust by clearly answering the question, *"Where did my performance go?"*.

## 2\. Goals & Non-Goals

### Goals

  * Create a unified model for processing all fees, taxes, and transaction costs.
  * Provide a clear, additive Gross-to-Net return bridge as a standard output.
  * Decompose cost impacts at the portfolio, group, and security level.
  * Support both `SUPPLIED` (from a ledger) and `COMPUTE` (from rules) modes for cost calculation.
  * Ensure cost effects are correctly linked over multiple periods and integrated into all core analytics engines.

### Non-Goals

  * The API will not perform tax optimization or manage tax lots (this would be a separate, future RFC).
  * The service remains stateless and does not serve as a book of record for costs.

## 3\. Methodology

The framework's core principle is to treat costs as a direct reduction of return, applied daily.

### 3.1. Core Principle: Gross-to-Net Bridge

For Time-Weighted Return (TWR), the most accurate method is **Numerator Adjustment**. The gross return is calculated first. Then, for each cost component *x*, its daily currency amount ($C^x\_t$) is used to calculate its impact on that day's return.

  * **Gross Daily Return**: $r^g\_t = \\frac{\\text{Gain/Loss}}{\\text{Denominator}}$
  * **Cost Effect (Daily)**: $e^x\_t = - \\frac{C^x\_t}{\\text{Denominator}}$
  * **Net Daily Return**: $r^n\_t = r^g\_t + \\sum\_x e^x\_t$

These daily effects are then linked over time using the same robust Carino smoothing as our Contribution engine, ensuring that over any period:
$$R^{net} = R^{gross} + \sum_x E^x$$
where $E^x$ is the total linked effect of cost component *x*.

### 3.2. Cost Component Calculation

  * **Management Fees (`COMPUTE` mode)**: Accrued daily based on the prior day's Net Asset Value (NAV) and the annual fee rate.
  * **Performance Fees (`COMPUTE` mode)**: Calculated at crystallization dates using a stateful engine that tracks **High-Water Marks (HWM)** and **hurdle rates**. Fees are only charged on performance exceeding these benchmarks.
  * **Transaction Costs (`MODEL` mode)**: Estimated based on turnover or trade activity, using parameters like `slippage_bps` and `commission_per_share`.

### 3.3. Cost Allocation Policies

For Contribution and Attribution, portfolio-level costs must be allocated down to individual securities. The `allocation.policy` controls this:

  * **`DIRECT_IF_AVAILABLE` (Default)**: If a cost is supplied with an instrument ID, it's allocated directly. Otherwise, a fallback is used.
  * **`PRO_RATA_MV`**: Allocates costs based on each security's average market value.
  * **`PRO_RATA_TURNOVER`**: Allocates transaction costs based on each security's trading activity.

## 4\. API Design

### 4.1. Request Additions (`costs` block)

The following block will be added to the shared request envelope for all relevant endpoints.

```json
{
  "costs": {
    "enabled": true,
    "basis": "BOTH",
    "management_fee": {
      "mode": "COMPUTE",
      "rate_pa": 0.01,
      "accrual": "DAILY_NAV"
    },
    "performance_fee": {
      "mode": "SUPPLIED",
      "supplied": []
    },
    "transaction_costs": {
      "mode": "SUPPLIED",
      "supplied": [
        {"date":"2025-02-10", "instrumentId":"AAPL", "commission":-15.2, "slippage":-21.1, "currency":"USD"}
      ]
    },
    "allocation": {
      "policy": "DIRECT_IF_AVAILABLE",
      "fallback": "PRO_RATA_MV"
    },
    "report": {
      "emit_bridge": true
    }
  }
}
```

### 4.2. Response Additions (`gross_net` bridge)

A `gross_net` block will be added to the top level of the response.

```json
{
  "gross_net": {
    "gross_return": 0.0910,
    "effects": {
      "management_fee_bp": -45.3,
      "performance_fee_bp": 0,
      "transaction_costs_bp": -18.7,
      "taxes_bp": -5.0
    },
    "net_return": 0.0841
  },
  "costs": {
    "by_component": [
      { "component": "management_fee", "amount": -22145.32, "bp": -45.3 }
    ]
  },
  "meta": { ... },
  "diagnostics": { ... },
  "audit": { ... }
}
```

### 4.3. HTTP Semantics & Errors

  * **200 OK**: Successful computation.
  * **400 Bad Request**: Invalid cost configuration (e.g., missing `rate_pa` in COMPUTE mode).
  * **422 Unprocessable Entity**: Request is valid, but data is insufficient (e.g., no NAV data available to compute fees).

## 5\. Architecture & Implementation Plan

1.  **Create New Module**:
      * `engine/costs.py`: To house the logic for calculating each cost component (especially the performance fee engine) and the allocation policies.
2.  **Integrate with Core Engines**:
      * `engine/ror.py` and `engine/compute.py` will be modified to incorporate the cost effects into the daily return calculation.
      * `engine/contribution.py` and `engine/attribution.py` will be enhanced to use the allocated cost effects.
3.  **Phased Rollout**:
      * **Phase 1**: Implement the TWR bridge with `SUPPLIED` costs and `COMPUTE` management fees.
      * **Phase 2**: Implement the complex `COMPUTE` performance fee engine.
      * **Phase 3**: Fully integrate the cost decomposition into Contribution and Attribution.

## 6\. Testing & Validation Strategy

  * **Unit Tests**: The new `engine/costs.py` module must achieve **100% test coverage**. This is especially critical for the performance fee state machine, which must be tested against various NAV paths (crossing HWM, hitting hurdles, resets).
  * **Integration Tests**: API-level tests will validate the end-to-end Gross-to-Net bridge for each core endpoint (TWR, Contribution, etc.).
  * **Characterization Test**: A test will be created for a multi-period TWR calculation with all cost types active. The final `net_return` and the sum of all `effects` will be validated against a reference calculation from a Jupyter notebook.
  * **Overall Coverage**: The overall project test coverage must remain at or above **95%**.

## 7\. Acceptance Criteria

The implementation of this RFC is complete when:

1.  This RFC is formally approved by all stakeholders.
2.  The `costs` block is added to the shared request envelope and is fully functional.
3.  All core analytics endpoints can produce a correct and fully reconciled Gross-to-Net bridge in their responses.
4.  The performance fee engine correctly implements HWM and hurdle logic.
5.  The testing and validation strategy is fully implemented, all tests are passing, and the required coverage targets are met.
6.  New documentation is added to `docs/guides/` and `docs/technical/` explaining the cost decomposition framework.