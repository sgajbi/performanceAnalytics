# RFC 026: Attribution Trading Effect (Final)

**Status:** Final (For Approval)
**Owner:** Senior Architect
**Reviewers:** Perf Engine, Risk, PMs
**Related:** RFC-018 (Attribution), RFC-021 (Costs), RFC-025 (Reproducibility)

## 1\. Executive Summary

This document specifies the final design for a sophisticated extension to our Brinson attribution engine: the **Trading Effect**. Standard Brinson attribution explains active return based on start-of-period weights and is excellent for analyzing strategic allocation and selection decisions. However, it does not isolate the value added or subtracted by a portfolio manager's **in-period trading activity**.

This RFC introduces an optional, configurable `Trading` component to the attribution model. It provides a clear, additive decomposition that preserves the fundamental reconciliation: **Allocation + Selection + Interaction + Trading = Total Active Return**.

To accommodate varying levels of data availability, the engine will support three distinct methodologies, from a simple **Holdings Residual** approach that requires no new data, to a highly precise **Event-Driven** method that uses a trade ledger. This enhancement provides a much deeper level of insight into a manager's skill, separating the performance of their initial holdings from the alpha generated by their active trading throughout the period.

## 2\. Goals & Non-Goals

### Goals

  * Extend the Brinson attribution model with an optional, additive **Trading effect**.
  * Offer three distinct calculation methods with increasing levels of precision and data requirements.
  * Ensure the extended attribution model continues to reconcile perfectly to the total active return.
  * Integrate seamlessly with the existing frameworks for transaction costs, multi-currency, and dynamic benchmarks.

### Non-Goals

  * This is not an intraday or microstructure analysis tool.
  * It will not analyze order routing or execution quality.
  * The API remains stateless and does not source trade ledgers.

## 3\. Methodology

The framework adds a fourth component, Trading (T), to the existing Allocation (A), Selection (S), and Interaction (I) effects.

### 3.1. Method A: Holdings Residual

This is the simplest method and requires no new data inputs. It defines the Trading effect as the portion of active return that cannot be explained by a static, beginning-of-period holdings analysis.

1.  **Calculate "Holdings-Only" Attribution**: First, the engine calculates a hypothetical attribution ($A\_H, S\_H, I\_H$) using the **start-of-period weights** held constant for the entire period.
2.  **Calculate Actual Attribution**: Next, it calculates the standard, actual attribution (A, S, I) using the portfolio's true, evolving daily weights.
3.  **Define Trading Effect**: The Trading effect is the residual difference:
    $$T = (A + S + I) - (A_H + S_H + I_H)$$

### 3.2. Method B: Average-Weight

This method provides a more refined approximation by defining the Trading effect as the impact of moving from start-of-period weights to the time-weighted average weights used during the period. It offers a balance between precision and data requirements.

### 3.3. Method C: Event-Driven

This is the most precise method, directly attributing the performance impact of each individual trade. It requires the user to supply a `trade_ledger`.

1.  **Isolate Trade Impact**: For each trade *j* at time $\\tau\_j$ that changes the active weight of a group by $\\Delta w\_j$, the engine calculates the ex-post active return of that group for the remainder of the period ($r^{active}\_{\\tau\_j \\to \\text{end}}$).
2.  **Calculate Trade Contribution**: The contribution of the trade to the Trading effect is:
    $$T_j = \Delta w_j \cdot r^{active}_{\tau_j \to \text{end}}$$
3.  **Aggregate**: The total Trading effect is the sum of the contributions of all trades, linked over time.

### 3.4. Interaction with Transaction Costs

To avoid double-counting, the Trading effect is calculated using **pre-cost** (gross) returns. The impact of commissions and slippage is handled by the **Transaction Costs Framework (RFC 021)** and can be reported as a separate, distinct component of the Gross-to-Net return bridge.

## 4\. API Design

### 4.1. Request Additions (`trading_effect` block)

The `/performance/attribution` request will be extended with a new, optional block.

```json
{
  "trading_effect": {
    "enabled": true,
    "method": "EVENT_DRIVEN",
    "event_time_assumption": "EOD",
    "transaction_cost_handling": "SEPARATE_COMPONENT",
    "trade_ledger": {
      "source": "SUPPLIED",
      "trades": [
        {
          "datetime": "2025-02-12T21:00:00Z",
          "instrumentId": "AAPL",
          "groupKey": { "sector": "Tech" },
          "quantity": 1200, "price": 182.35, "currency": "USD",
          "fees": -85.2, "side": "BUY"
        }
      ]
    }
  }
}
```

### 4.2. Response Additions

The `attribution` response will include the new `trading` component.

```json
{
  "reconciliation": {
    "portfolio_minus_benchmark_pct": 2.33,
    "sum_components_pct": 2.33,
    "residual_bp": 0.0
  },
  "effects": {
    "allocation": 0.48,
    "selection": 0.65,
    "interaction": 0.08,
    "trading": 1.12
  },
  "levels": [
    {
      "level": "sector",
      "rows": [
        { "key": {"sector": "Tech"}, "A": 0.3, "S": 0.4, "I": 0.1, "T": 0.9 }
      ]
    }
  ],
  ...
}
```

### 4.3. HTTP Semantics & Errors

  * **200 OK**: Successful computation.
  * **400 Bad Request**: Invalid `trading_effect` configuration.
  * **422 Unprocessable Entity**: Request is valid, but required data is missing (e.g., `trade_ledger` for `EVENT_DRIVEN` method).

## 5\. Architecture & Implementation Plan

1.  **Extend Attribution Engine**: The logic will be added to `engine/attribution.py`. No new top-level engine module is required.
2.  **Implement Method A (Residual)**: This is the first and simplest implementation, providing immediate value.
3.  **Implement Method C (Event-Driven)**: This is the most complex but highest-value implementation. It will require new logic to process the `trade_ledger` and align it with the return series.
4.  **Integrate with Cost Engine**: Ensure the calculation correctly separates the Trading effect from the Transaction Cost effect as defined in RFC 021.

## 6\. Testing & Validation Strategy

  * **Unit Tests**: The modified `engine/attribution.py` must maintain **100% test coverage**. This will include dedicated tests for each of the three trading effect methodologies, validating their outputs on synthetic data.
  * **Integration Tests**: API-level tests will be created to validate the end-to-end flow, ensuring the `trading_effect` block is correctly parsed and that the final response reconciles.
  * **Characterization Test**: A test will be created using a portfolio with a small number of trades over a period. The `EVENT_DRIVEN` trading effect will be validated against a manual, step-by-step calculation in a reference notebook.
  * **Overall Coverage**: The overall project test coverage must remain at or above **95%**.

## 7\. Acceptance Criteria

The implementation of this RFC is complete when:

1.  This RFC is formally approved by all stakeholders.
2.  The `/performance/attribution` endpoint is enhanced with the optional `trading_effect` block, supporting all three specified methods.
3.  The extended attribution model (A+S+I+T) is proven to reconcile to the total active return for all methods.
4.  The testing and validation strategy is fully implemented, all tests are passing, and the required coverage targets are met.
5.  The characterization test passes, confirming the numerical correctness of the Event-Driven method.
6.  New documentation is added to `docs/guides/` and `docs/technical/` explaining the Trading Effect feature.